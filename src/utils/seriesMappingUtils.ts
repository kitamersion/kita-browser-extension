import { seriesMappingStorage } from "@/api/seriesMapping";
import { ISeriesMapping, SourcePlatform } from "@/types/integrations/seriesMapping";
import logger from "@/config/logger";

/**
 * Series Mapping Utilities
 * Helper functions for managing and debugging series mappings
 */
export class SeriesMappingUtils {
  /**
   * Debug: List all mappings for a platform
   */
  static async listMappingsForPlatform(platform: SourcePlatform): Promise<void> {
    const mappings = await seriesMappingStorage.getMappingsByPlatform(platform);
    logger.info(`=== ${platform.toUpperCase()} MAPPINGS (${mappings.length}) ===`);

    mappings.forEach((mapping, index) => {
      logger.info(`${index + 1}. ${mapping.series_title} (${mapping.season_year || "Any Season"})`);
      logger.info(`   -> AniList ID: ${mapping.anilist_series_id}`);
      logger.info(`   -> User Confirmed: ${mapping.user_confirmed}`);
      logger.info(`   -> Expires: ${new Date(mapping.expires_at).toLocaleDateString()}`);
      logger.info(`   -> Mapping ID: ${mapping.id}`);
    });
  }

  /**
   * Debug: List all mappings
   */
  static async listAllMappings(): Promise<void> {
    const mappings = await seriesMappingStorage.getAllMappings();
    logger.info(`=== ALL SERIES MAPPINGS (${mappings.length}) ===`);

    const grouped = mappings.reduce(
      (acc, mapping) => {
        if (!acc[mapping.source_platform]) acc[mapping.source_platform] = [];
        acc[mapping.source_platform].push(mapping);
        return acc;
      },
      {} as Record<SourcePlatform, ISeriesMapping[]>
    );

    Object.entries(grouped).forEach(([platform, platformMappings]) => {
      logger.info(`\n--- ${platform.toUpperCase()} (${platformMappings.length}) ---`);
      platformMappings.forEach((mapping) => {
        logger.info(`${mapping.series_title} -> AniList ID: ${mapping.anilist_series_id}`);
      });
    });
  }

  /**
   * Search for mappings by title (fuzzy)
   */
  static async searchMappings(searchTerm: string): Promise<ISeriesMapping[]> {
    const allMappings = await seriesMappingStorage.getAllMappings();
    const normalizedSearch = searchTerm.toLowerCase();

    return allMappings.filter(
      (mapping) => mapping.series_title.toLowerCase().includes(normalizedSearch) || mapping.normalized_title.includes(normalizedSearch)
    );
  }

  /**
   * Clean up expired mappings manually (usually done automatically)
   */
  static async cleanExpiredMappings(): Promise<number> {
    const allMappings = await seriesMappingStorage.getAllMappings();
    const now = Date.now();
    const expired = allMappings.filter((mapping) => mapping.expires_at <= now);

    for (const mapping of expired) {
      await seriesMappingStorage.removeMapping(mapping.id);
    }

    logger.info(`Cleaned up ${expired.length} expired mappings`);
    return expired.length;
  }

  /**
   * Get mapping statistics
   */
  static async getMappingStats(): Promise<{
    total: number;
    byPlatform: Record<SourcePlatform, number>;
    userConfirmed: number;
    autoGenerated: number;
    expiringSoon: number; // Within 30 days
  }> {
    const mappings = await seriesMappingStorage.getAllMappings();
    const now = Date.now();
    const thirtyDaysMs = 30 * 24 * 60 * 60 * 1000;

    const byPlatform = mappings.reduce(
      (acc, mapping) => {
        acc[mapping.source_platform] = (acc[mapping.source_platform] || 0) + 1;
        return acc;
      },
      {} as Record<SourcePlatform, number>
    );

    return {
      total: mappings.length,
      byPlatform,
      userConfirmed: mappings.filter((m) => m.user_confirmed).length,
      autoGenerated: mappings.filter((m) => !m.user_confirmed).length,
      expiringSoon: mappings.filter((m) => m.expires_at - now < thirtyDaysMs).length,
    };
  }

  /**
   * Export mappings as JSON (for backup)
   */
  static async exportMappings(): Promise<string> {
    const mappings = await seriesMappingStorage.getAllMappings();
    return JSON.stringify(mappings, null, 2);
  }

  /**
   * Import mappings from JSON (for restore)
   * WARNING: This will overwrite existing mappings!
   */
  static async importMappings(jsonData: string): Promise<number> {
    try {
      const mappings: ISeriesMapping[] = JSON.parse(jsonData);

      // Validate the data structure
      if (!Array.isArray(mappings)) {
        throw new Error("Invalid data format: expected array");
      }

      // Clear existing mappings (optional - comment out to merge instead)
      const existingMappings = await seriesMappingStorage.getAllMappings();
      for (const existing of existingMappings) {
        await seriesMappingStorage.removeMapping(existing.id);
      }

      // Import new mappings
      for (const mapping of mappings) {
        await seriesMappingStorage.createMapping({
          series_title: mapping.series_title,
          source_platform: mapping.source_platform,
          season_year: mapping.season_year,
          anilist_series_id: mapping.anilist_series_id,
          mal_series_id: mapping.mal_series_id,
          total_episodes: mapping.total_episodes,
          cover_image: mapping.cover_image,
          series_description: mapping.series_description,
          user_confirmed: mapping.user_confirmed,
        });
      }

      logger.info(`Imported ${mappings.length} series mappings`);
      return mappings.length;
    } catch (error) {
      logger.error("Failed to import mappings");
      throw error;
    }
  }
}

// Make utilities available globally for debugging in console
if (typeof window !== "undefined") {
  (window as any).SeriesMappingUtils = SeriesMappingUtils;
}
